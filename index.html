<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#007bff">
  <title>Crispydelight Restaurant</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f0f0f0;
      font-size: 16px;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }
    .container {
      max-width: 360px;
      margin: 0 auto;
      text-align: center;
    }
    h1, h2, h3, h4, h5 {
      color: #333;
    }
    button {
      padding: 12px;
      margin: 8px 4px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      min-height: 44px;
      touch-action: manipulation;
    }
    .btn-blue { background-color: #007bff; color: white; }
    .btn-blue:hover { background-color: #0056b3; }
    .btn-green { background-color: #28a745; color: white; }
    .btn-green:hover { background-color: #1e7e34; }
    .btn-purple { background-color: #6f42c1; color: white; }
    .btn-purple:hover { background-color: #5a32a3; }
    .btn-gray { background-color: #6c757d; color: white; }
    .btn-gray:hover { background-color: #545b62; }
    .btn-red { background-color: #dc3545; color: white; }
    .btn-red:hover { background-color: #bd2130; }
    .btn-disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .table-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      align-items: center;
    }
    .table-grid label {
      font-size: 14px;
      margin-left: 5px;
    }
    .order-item, .kitchen-order, .admin-order, .history-order {
      background-color: white;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .order-item.new, .kitchen-order.new, .history-order.new {
      opacity: 0;
      transform: translateY(10px);
      animation: fadeIn 0.3s forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; transform: translateY(0); }
    }
    input, select {
      padding: 8px;
      margin: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
    }
    .logo {
      max-width: 100px;
      margin: 10px auto;
    }
    .loading {
      display: none;
      font-size: 14px;
      color: #666;
      text-align: center;
      margin: 10px 0;
    }
    .loading.active {
      display: block;
    }
    .total-sum {
      font-weight: bold;
      margin-top: 10px;
    }
    .category-group {
      margin: 10px 0;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
    }
    .timestamp {
      font-size: 12px;
      color: #666;
      margin: 5px 0;
    }
    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    .pagination button {
      min-width: 44px;
    }
    .sticky-header {
      position: sticky;
      top: 0;
      background-color: #f0f0f0;
      z-index: 10;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .item-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div id="loading" class="loading">Loading...</div>
  <div class="container" id="app">
    <img src="https://via.placeholder.com/100x50?text=Crispydelight" alt="Crispydelight Logo" class="logo">
  </div>
  <script>
    const DATABASE_URL = 'https://crispydelight-7ec1d-default-rtdb.firebaseio.com/';
    const domCache = { app: document.getElementById('app'), loading: document.getElementById('loading') };
    const state = {
      currentSection: 'home',
      selectedTable: null,
      selectedOrderId: null,
      tables: 10,
      takeaway: true,
      currentOrder: {},
      currentPage: 1,
      itemsPerPage: 5, // Categories per page
      tableTakeawayStates: {},
      lastOrdersState: {},
      actionQueue: [],
      isFetching: false,
      pollTimer: null
    };
    const menu = [
      { id: 1, name: 'Classic Veg Burger', price: 59, category: 'Burgers', isFavorite: false },
      { id: 2, name: 'Cheesy Veg Burger', price: 69, category: 'Burgers', isFavorite: false },
      { id: 3, name: 'Paneer Burger', price: 89, category: 'Burgers', isFavorite: false },
      { id: 4, name: 'Cheesy Paneer Burger', price: 99, category: 'Burgers', isFavorite: false },
      { id: 5, name: 'Classic Chicken Burger', price: 89, category: 'Burgers', isFavorite: false },
      { id: 6, name: 'Cheesy Chicken Burger', price: 99, category: 'Burgers', isFavorite: false },
      { id: 7, name: 'Fried Chicken Burger', price: 119, category: 'Burgers', isFavorite: false },
      { id: 8, name: 'Cheesy Fried Chicken Burger', price: 129, category: 'Burgers', isFavorite: false },
      { id: 9, name: 'Super Tower Veg Burger', price: 129, category: 'Burgers', isFavorite: false },
      { id: 10, name: 'Super Tower Chicken Burger', price: 139, category: 'Burgers', isFavorite: false },
      { id: 11, name: 'No Bun Fried Chicken Burger', price: 199, category: 'Special Menu', isFavorite: false },
      { id: 12, name: 'Reverse Fried Chicken Burger', price: 199, category: 'Special Menu', isFavorite: false },
      { id: 13, name: 'Cheesy Overloaded Fries', price: 119, category: 'Special Menu', isFavorite: false },
      { id: 14, name: 'Mayonnaise', price: 10, category: 'Extras', isFavorite: false },
      { id: 15, name: 'Flavored Mayonnaise', price: 20, category: 'Extras', isFavorite: false },
      { id: 16, name: 'Fried Chicken Leg', price: 79, category: 'Fried Chicken', isFavorite: false },
      { id: 17, name: 'Chicken Nuggets', price: 89, category: 'Fried Chicken', isFavorite: false },
      { id: 18, name: 'Fried Chicken Wings', price: 99, category: 'Fried Chicken', isFavorite: false },
      { id: 19, name: 'Fried Chicken Lollipop', price: 99, category: 'Fried Chicken', isFavorite: false },
      { id: 20, name: 'Chicken Mini Popcorn (10 pieces)', price: 99, category: 'Fried Chicken', isFavorite: false },
      { id: 21, name: 'Chicken Popcorn (18 pieces)', price: 159, category: 'Fried Chicken', isFavorite: false },
      { id: 22, name: 'Chicken Strips (3 pieces)', price: 149, category: 'Fried Chicken', isFavorite: false },
      { id: 23, name: 'Veg Pizza', price: 69, category: 'Pizza', isFavorite: false },
      { id: 24, name: 'Corn Pizza', price: 79, category: 'Pizza', isFavorite: false },
      { id: 25, name: 'Paneer Pizza', price: 89, category: 'Pizza', isFavorite: false },
      { id: 26, name: 'Cheese Pizza', price: 99, category: 'Pizza', isFavorite: false },
      { id: 27, name: 'Fried Chicken Pizza', price: 129, category: 'Pizza', isFavorite: false },
      { id: 28, name: 'Hot & Spicy Chicken Pizza', price: 149, category: 'Pizza', isFavorite: false },
      { id: 29, name: 'Delight Spl Veg Pizza (9")', price: 139, category: 'Pizza', isFavorite: false },
      { id: 30, name: 'Delight Spl Chicken Pizza (9")', price: 159, category: 'Pizza', isFavorite: false },
      { id: 31, name: 'Cheesy Overloaded Pizza (9")', price: 199, category: 'Pizza', isFavorite: false },
      { id: 32, name: 'Chicken OER, French Fries, Soft Drink', price: 129, category: 'Non-Veg Combos', isFavorite: false },
      { id: 33, name: 'Hot & Spicy Chicken Pizza, Blue Sky Mojito, French Fries', price: 249, category: 'Non-Veg Combos', isFavorite: false },
      { id: 34, name: 'Delight Spl Chicken Pizza, Fried Chicken Momo, Peri Peri Fries, Mojito, Fried Lego (1 pc), Lollipop (1 pc)', price: 499, category: 'Non-Veg Combos', isFavorite: false },
      { id: 35, name: 'Veg Sandwich', price: 69, category: 'Sandwich', isFavorite: false },
      { id: 36, name: 'Cheesy Veg Sandwich', price: 79, category: 'Sandwich', isFavorite: false },
      { id: 37, name: 'Corn Sandwich', price: 89, category: 'Sandwich', isFavorite: false },
      { id: 38, name: 'Cheesy Corn Sandwich', price: 99, category: 'Sandwich', isFavorite: false },
      { id: 39, name: 'Paneer Sandwich', price: 99, category: 'Sandwich', isFavorite: false },
      { id: 40, name: 'Cheesy Paneer Sandwich', price: 199, category: 'Sandwich', isFavorite: false },
      { id: 41, name: 'Fried Chicken Sandwich', price: 129, category: 'Sandwich', isFavorite: false },
      { id: 42, name: 'Cheesy Chicken Sandwich', price: 139, category: 'Sandwich', isFavorite: false },
      { id: 43, name: 'Normal Fries', price: 59, category: 'Fries', isFavorite: false },
      { id: 44, name: 'Peri-Peri Fries', price: 69, category: 'Fries', isFavorite: false },
      { id: 45, name: 'Peri-Peri Fries with Mayonnaise', price: 89, category: 'Fries', isFavorite: false },
      { id: 46, name: 'Mixed Veg Fried Momo', price: 89, category: 'Momo', isFavorite: false },
      { id: 47, name: 'Paneer Fried Momo', price: 99, category: 'Momo', isFavorite: false },
      { id: 48, name: 'Chicken Fried Momo', price: 99, category: 'Momo', isFavorite: false },
      { id: 49, name: 'Fried Leg (3 pcs)', price: 209, category: 'Fried Chicken Combos', isFavorite: false },
      { id: 50, name: '10 pc Fried Chicken', price: 249, category: 'Fried Chicken Combos', isFavorite: false },
      { id: 51, name: 'Bucket Chicken', price: 349, category: 'Fried Chicken Combos', isFavorite: false },
      { id: 52, name: 'Mixed Bucket Chicken (3 leg, 4 wings, 3 lollipop, 3 pc popcorn)', price: 425, category: 'Fried Chicken Combos', isFavorite: false },
      { id: 53, name: '20 pc Popcorn + Peri Peri Fries', price: 249, category: 'Fried Chicken Combos', isFavorite: false },
      { id: 54, name: 'Bread Omelette', price: 69, category: 'Bread Omelette', isFavorite: false },
      { id: 55, name: 'Double Bread Omelette', price: 79, category: 'Bread Omelette', isFavorite: false },
      { id: 56, name: 'Cheesy Double Bread Omelette', price: 99, category: 'Bread Omelette', isFavorite: false },
      { id: 57, name: 'Delight Spl Veg Wrap', price: 99, category: 'Wraps', isFavorite: false },
      { id: 58, name: 'Delight Spl Chicken Wrap', price: 119, category: 'Wraps', isFavorite: false },
      { id: 59, name: 'Delight Spl Fried Chicken Wrap', price: 139, category: 'Wraps', isFavorite: false },
      { id: 60, name: 'Brownie with Ice Cream', price: 99, category: 'Desserts', isFavorite: false },
      { id: 61, name: 'Death by Chocolate', price: 119, category: 'Desserts', isFavorite: false },
      { id: 62, name: 'Rose Milk', price: 39, category: 'Milkshakes', isFavorite: false },
      { id: 63, name: 'Chocolate', price: 89, category: 'Milkshakes', isFavorite: false },
      { id: 64, name: 'Oreo', price: 89, category: 'Milkshakes', isFavorite: false },
      { id: 65, name: 'Vanilla', price: 89, category: 'Milkshakes', isFavorite: false },
      { id: 66, name: 'Mango', price: 79, category: 'Milkshakes', isFavorite: false },
      { id: 67, name: 'KitKat', price: 89, category: 'Milkshakes', isFavorite: false },
      { id: 68, name: 'Strawberry', price: 79, category: 'Milkshakes', isFavorite: false },
      { id: 69, name: 'Vanilla Sundae', price: 69, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 70, name: 'Chocolate Sundae', price: 79, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 71, name: 'Butterscotch Sundae', price: 79, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 72, name: 'Strawberry Sundae', price: 79, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 73, name: 'Cookies & Cream Sundae', price: 99, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 74, name: 'Italian Chocolate Sundae', price: 99, category: 'Ice Cream Sundaes', isFavorite: false },
      { id: 75, name: 'Blue Sky Mojito', price: 79, category: 'Mojitos', isFavorite: false },
      { id: 76, name: 'Mint Lime Mojito', price: 79, category: 'Mojitos', isFavorite: false },
      { id: 77, name: 'Virgin Mojito', price: 79, category: 'Mojitos', isFavorite: false }
    ];
    const categories = [
      'Burgers', 'Special Menu', 'Extras', 'Fried Chicken', 'Pizza', 'Non-Veg Combos',
      'Sandwich', 'Fries', 'Momo', 'Fried Chicken Combos', 'Bread Omelette', 'Wraps',
      'Desserts', 'Milkshakes', 'Ice Cream Sundaes', 'Mojitos'
    ];

    /**
     * Debounces a function to limit execution rate
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in milliseconds
     * @returns {Function} Debounced function
     */
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    /**
     * Queues an action to run after fetching completes
     * @param {Function} action - Action to queue
     * @param {string} type - Type of action for logging
     */
    function queueAction(action, type) {
      if (state.isFetching) {
        state.actionQueue.push({ action, type });
        console.log(`Action queued: ${type}`);
      } else {
        action();
      }
    }

    /**
     * Processes queued actions
     */
    function processQueue() {
      while (state.actionQueue.length > 0) {
        const { action, type } = state.actionQueue.shift();
        console.log(`Processing queued action: ${type}`);
        action();
      }
    }

    /**
     * Performs a fetch with retry logic
     * @param {string} url - URL to fetch
     * @param {Object} options - Fetch options
     * @param {number} retries - Number of retries
     * @returns {Promise<Response>} Fetch response
     */
    async function fetchWithRetry(url, options = {}, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          return response;
        } catch (error) {
          if (i === retries - 1) throw error;
          console.warn(`Fetch failed, retrying (${i + 1}/${retries}): ${url}`);
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    /**
     * Loads configuration from Firebase
     */
    async function loadConfig() {
      showLoading(true);
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}config.json`);
        const config = await response.json();
        if (config) {
          state.tables = config.tables || state.tables;
          state.takeaway = config.takeaway !== undefined ? config.takeaway : state.takeaway;
          // Preserve local menu/categories unless Firebase overrides
          if (config.menu) menu.length = 0; menu.push(...config.menu);
          if (config.categories) categories.length = 0; categories.push(...config.categories);
        }
        console.log('Config loaded:', { tables: state.tables, takeaway: state.takeaway, menu, categories });
      } catch (error) {
        console.error('Failed to load config:', error);
        alert(`Error loading configuration: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }
      showLoading(false);
      render();
    }

    /**
     * Saves configuration to Firebase
     */
    async function saveConfig() {
      showLoading(true);
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}config.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tables: state.tables, takeaway: state.takeaway, menu, categories })
        });
        console.log('Config saved:', { tables: state.tables, takeaway: state.takeaway, menu, categories });
      } catch (error) {
        console.error('Failed to save config:', error);
        alert(`Error saving configuration: ${error.message}. Check Firebase rules or network.`);
      }
      showLoading(false);
    }

    /**
     * Toggles loading indicator
     * @param {boolean} show - Whether to show the loading indicator
     */
    function showLoading(show) {
      if (domCache.loading) {
        domCache.loading.classList.toggle('active', show);
      } else {
        console.warn('Loading element not found');
      }
    }

    /**
     * Renders the current section
     */
    function render() {
      if (!domCache.app) {
        console.error('App container not found');
        return;
      }
      domCache.app.innerHTML = `
        <img src="https://via.placeholder.com/100x50?text=Crispydelight" alt="Crispydelight Logo" class="logo">
      `;

      switch (state.currentSection) {
        case 'home':
          domCache.app.innerHTML += `
            <h1>Crispydelight Dashboard</h1>
            <button class="btn-blue" onclick="navigate('order')">Order Section</button>
            <button class="btn-green" onclick="navigate('kitchen')">Kitchen Section</button>
            <button class="btn-purple" onclick="navigate('admin')">Admin Section</button>
            <button class="btn-blue" onclick="navigate('history')">Today's History</button>
          `;
          break;
        case 'order':
          if (state.selectedTable) {
            renderMenuSection();
          } else {
            renderOrderSection();
          }
          break;
        case 'kitchen':
          renderKitchenSection();
          break;
        case 'admin':
          renderAdminSection();
          break;
        case 'history':
          renderHistorySection();
          break;
      }
      showLoading(false);
      console.log('Rendered section:', state.currentSection, 'Selected table:', state.selectedTable, 'Selected order:', state.selectedOrderId);
    }

    /**
     * Navigates to a new section
     * @param {string} section - Section to navigate to
     */
    function navigate(section) {
      if (state.pollTimer) {
        clearTimeout(state.pollTimer);
        state.pollTimer = null;
        console.log('Polling stopped');
      }
      state.currentSection = section;
      state.selectedTable = null;
      state.selectedOrderId = null;
      state.currentOrder = {};
      state.currentPage = 1;
      state.lastOrdersState = {};
      showLoading(false);
      render();
      startPolling();
    }

    /**
     * Starts polling for updates
     */
    function startPolling() {
      if (state.pollTimer) clearTimeout(state.pollTimer);
      if (state.currentSection === 'order' && !state.selectedTable) {
        renderOrderSection();
        state.pollTimer = setTimeout(startPolling, 20000); // 20s for battery optimization
        console.log('Polling started for order (table selection)');
      } else if (state.currentSection === 'kitchen') {
        renderKitchenSection();
        state.pollTimer = setTimeout(startPolling, 20000);
        console.log('Polling started for kitchen');
      } else {
        console.log('Polling skipped: section=', state.currentSection, 'selectedTable=', state.selectedTable);
      }
    }

    /**
     * Renders the order section (table selection)
     */
    async function renderOrderSection() {
      if (state.currentSection !== 'order' || state.selectedTable) {
        console.log('Skipping renderOrderSection: section=', state.currentSection, 'selectedTable=', state.selectedTable);
        return;
      }
      state.isFetching = true;
      showLoading(true);
      let orders = [];
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'pending' || o.status === 'ready')
          .sort((a, b) => a.timestamp - b.timestamp) : [];
        console.log('Orders fetched:', orders);
        updateOrdersDOM(orders, 'order', 'order-item');
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert(`Error loading orders: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }
      showLoading(false);
      state.isFetching = false;
      processQueue();
    }

    /**
     * Updates the DOM with orders
     * @param {Array} orders - List of orders
     * @param {string} section - Section name
     * @param {string} className - CSS class for order elements
     */
    function updateOrdersDOM(orders, section, className) {
      if (!domCache.app) return;

      const newState = JSON.stringify(orders.map(o => ({ id: o.id, status: o.status, timestamp: o.timestamp })));
      if (newState === state.lastOrdersState[section]) {
        console.log(`No changes in ${section} orders, skipping DOM update`);
        return;
      }
      state.lastOrdersState[section] = newState;

      const currentOrderEls = Array.from(document.getElementsByClassName(className));
      const currentOrderIds = currentOrderEls.map(el => el.id.replace(`${section}-`, ''));

      const newOrderIds = orders.map(o => o.id);

      currentOrderEls.forEach(el => {
        if (!newOrderIds.includes(el.id.replace(`${section}-`, ''))) {
          el.style.opacity = '0';
          setTimeout(() => el.remove(), 300);
        }
      });

      let html = `
        <h2>${section.charAt(0).toUpperCase() + section.slice(1)} Section</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
      `;
      if (section === 'order') {
        html += `
          <h3>Place Order</h3>
          <div class="table-grid">
            ${Array.from({ length: state.tables }, (_, i) => `
              <div>
                <button class="btn-blue" onclick="selectTable('Table ${i + 1}')">Table ${i + 1}</button>
              </div>
            `).join('')}
          </div>
          <h3>Current Orders</h3>
        `;
      }

      const ordersContainer = document.createElement('div');
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const isNew = !currentOrderIds.includes(order.id);
        let orderHtml = `
          <div class="${className} ${isNew ? 'new' : ''}" id="${section}-${order.id}">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Status: ${order.status}</p>
            <button class="btn-blue" onclick="editOrder('${order.id}', '${order.table}')">Edit Order</button>
        `;
        if (order.status === 'ready') {
          orderHtml += `<button class="btn-green" onclick="markPaid('${order.id}', this)">Mark Paid</button>`;
        }
        orderHtml += `</div>`;
        ordersContainer.innerHTML += orderHtml;
      });

      domCache.app.innerHTML = html;
      domCache.app.appendChild(ordersContainer);
      showLoading(false);
    }

    /**
     * Selects a table and resets state if null
     * @param {string|null} table - Table name or null to go back
     */
    function selectTable(table) {
      queueAction(() => {
        console.log('selectTable called with:', table);
        state.selectedTable = table;
        state.selectedOrderId = null;
        state.currentOrder = {};
        state.currentPage = 1;
        if (!table) {
          state.tableTakeawayStates = {};
        }
        render();
      }, 'selectTable');
    }

    /**
     * Edits an existing order
     * @param {string} orderId - Order ID
     * @param {string} table - Table name
     */
    async function editOrder(orderId, table) {
      queueAction(async () => {
        showLoading(true);
        try {
          const response = await fetchWithRetry(`${DATABASE_URL}orders/${orderId}.json`);
          const order = await response.json();
          if (!order) throw new Error('Order not found');
          state.selectedTable = table;
          state.selectedOrderId = orderId;
          state.currentOrder = {};
          order.items.forEach(item => {
            const key = `${item.id}`;
            state.currentOrder[key] = { quantity: item.quantity, isTakeaway: item.isTakeaway };
          });
          console.log('Editing order:', orderId, state.currentOrder);
          render();
        } catch (error) {
          console.error('Failed to load order for editing:', error);
          alert(`Error loading order: ${error.message}. Check Firebase rules, endpoint, or network.`);
        }
        showLoading(false);
      }, 'editOrder');
    }

    /**
     * Renders the menu section with per-item takeaway checkboxes
     */
    function renderMenuSection() {
      if (!domCache.app) return;

      const total = Object.entries(state.currentOrder).reduce((sum, [key, { quantity }]) => {
        const itemId = parseInt(key);
        const item = menu.find(m => m.id === itemId);
        return sum + (item ? item.price * quantity : 0);
      }, 0);

      // Pagination by categories
      const totalPages = Math.ceil(categories.length / state.itemsPerPage);
      const startIndex = (state.currentPage - 1) * state.itemsPerPage;
      const endIndex = startIndex + state.itemsPerPage;
      const paginatedCategories = categories.slice(startIndex, endIndex);

      let html = `
        <div class="sticky-header">
          <h2>${state.selectedTable} ${state.selectedOrderId ? 'Edit Order' : 'Order'}</h2>
          <button class="btn-gray" onclick="selectTable(null)">Back</button>
          <p class="total-sum">Total: ₹${total}</p>
          <select onchange="jumpToCategory(this.value)">
            <option value="">Jump to Category</option>
            ${categories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
          </select>
        </div>
      `;

      // Render favorites
      const favoriteItems = menu.filter(item => item.isFavorite);
      if (favoriteItems.length > 0) {
        html += `<div class="category-group"><h3>Favorites</h3>`;
        favoriteItems.forEach(item => {
          const key = `${item.id}`;
          const order = state.currentOrder[key] || { quantity: 0, isTakeaway: false };
          html += `
            <div class="order-item">
              <span>${item.name} (₹${item.price})</span>
              <div class="item-controls">
                <button class="btn-red" onclick="updateOrder(${item.id}, -1, ${order.isTakeaway})">-</button>
                <span>${order.quantity}</span>
                <button class="btn-green" onclick="updateOrder(${item.id}, 1, ${order.isTakeaway})">+</button>
                <label><input type="checkbox" ${order.isTakeaway ? 'checked' : ''} onchange="updateOrder(${item.id}, 0, this.checked)"> Takeaway</label>
              </div>
            </div>
          `;
        });
        html += `</div>`;
      }

      // Render paginated categories
      paginatedCategories.forEach(category => {
        const categoryItems = menu.filter(item => item.category === category);
        if (categoryItems.length > 0) {
          html += `<div class="category-group"><h3>${category}</h3>`;
          categoryItems.forEach(item => {
            const key = `${item.id}`;
            const order = state.currentOrder[key] || { quantity: 0, isTakeaway: false };
            html += `
              <div class="order-item">
                <span>${item.name} (₹${item.price})</span>
                <div class="item-controls">
                  <button class="btn-red" onclick="updateOrder(${item.id}, -1, ${order.isTakeaway})">-</button>
                  <span>${order.quantity}</span>
                  <button class="btn-green" onclick="updateOrder(${item.id}, 1, ${order.isTakeaway})">+</button>
                  <label><input type="checkbox" ${order.isTakeaway ? 'checked' : ''} onchange="updateOrder(${item.id}, 0, this.checked)"> Takeaway</label>
                </div>
              </div>
            `;
          });
          html += `</div>`;
        }
      });

      html += `<button class="btn-blue" onclick="confirmOrder()">Confirm ${state.selectedOrderId ? 'Updated ' : ''}Order</button>`;

      // Pagination controls
      html += `
        <div class="pagination">
          <button class="btn-blue" ${state.currentPage === 1 ? 'disabled' : ''} onclick="changePage(${state.currentPage - 1})">Previous</button>
          <span>Page ${state.currentPage} of ${totalPages}</span>
          <button class="btn-blue" ${state.currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${state.currentPage + 1})">Next</button>
        </div>
      `;

      domCache.app.innerHTML = html;
      console.log('Menu section rendered: Table=', state.selectedTable, 'Total=', total, 'Page=', state.currentPage, 'Categories=', paginatedCategories);
    }

    /**
     * Jumps to a category by adjusting the page
     * @param {string} category - Category to jump to
     */
    function jumpToCategory(category) {
      if (!category) return;
      const index = categories.indexOf(category);
      if (index >= 0) {
        state.currentPage = Math.floor(index / state.itemsPerPage) + 1;
        render();
      }
    }

    /**
     * Changes the current page
     * @param {number} page - Page number
     */
    function changePage(page) {
      state.currentPage = Math.max(1, Math.min(page, Math.ceil(categories.length / state.itemsPerPage)));
      render();
    }

    /**
     * Updates an order item
     * @param {number} itemId - Item ID
     * @param {number} delta - Quantity change
     * @param {boolean} isTakeaway - Takeaway status
     */
    function updateOrder(itemId, delta, isTakeaway) {
      queueAction(() => {
        const key = `${itemId}`;
        if (!state.currentOrder[key]) {
          state.currentOrder[key] = { quantity: 0, isTakeaway: false };
        }
        if (delta !== 0) {
          state.currentOrder[key].quantity = (state.currentOrder[key].quantity || 0) + delta;
          if (state.currentOrder[key].quantity <= 0) {
            delete state.currentOrder[key];
          }
        } else {
          state.currentOrder[key].isTakeaway = isTakeaway;
        }
        render();
      }, 'updateOrder');
    }

    /**
     * Confirms the current order
     */
    async function confirmOrder() {
      queueAction(async () => {
        const button = domCache.app.querySelector('button[onclick="confirmOrder()"]');
        button.disabled = true;
        button.classList.add('btn-disabled');
        button.textContent = 'Processing...';
        const items = Object.entries(state.currentOrder).map(([key, { quantity, isTakeaway }]) => {
          const itemId = parseInt(key);
          const item = menu.find(m => m.id === itemId);
          return { ...item, quantity, isTakeaway };
        }).filter(item => item.quantity > 0);
        if (items.length === 0) {
          alert('Please add items to the order.');
          button.disabled = false;
          button.classList.remove('btn-disabled');
          button.textContent = `Confirm ${state.selectedOrderId ? 'Updated ' : ''}Order`;
          return;
        }

        showLoading(true);
        try {
          const url = state.selectedOrderId ? `${DATABASE_URL}orders/${state.selectedOrderId}.json` : `${DATABASE_URL}orders.json`;
          const method = state.selectedOrderId ? 'PUT' : 'POST';
          const body = {
            table: state.selectedTable,
            items,
            status: 'pending',
            timestamp: Date.now()
          };
          const response = await fetchWithRetry(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
          console.log(`${state.selectedOrderId ? 'Order updated' : 'Order confirmed'}:`, { table: state.selectedTable, items });
          state.currentOrder = {};
          state.selectedTable = null;
          state.selectedOrderId = null;
          render();
          startPolling();
        } catch (error) {
          console.error(`Failed to ${state.selectedOrderId ? 'update' : 'confirm'} order:`, error);
          alert(`Error ${state.selectedOrderId ? 'updating' : 'confirming'} order: ${error.message}. Check Firebase rules, endpoint, or network.`);
        }
        button.disabled = false;
        button.classList.remove('btn-disabled');
        button.textContent = `Confirm ${state.selectedOrderId ? 'Updated ' : ''}Order`;
        showLoading(false);
      }, 'confirmOrder');
    }

    /**
     * Renders the kitchen section
     */
    async function renderKitchenSection() {
      if (state.currentSection !== 'kitchen') {
        console.log('Skipping renderKitchenSection: not in kitchen section');
        return;
      }
      state.isFetching = true;
      showLoading(true);
      let orders = [];
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'pending')
          .sort((a, b) => a.timestamp - b.timestamp) : [];
        console.log('Kitchen orders fetched:', orders);
        updateKitchenOrdersDOM(orders);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert(`Error loading kitchen orders: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }
      showLoading(false);
      state.isFetching = false;
      processQueue();
    }

    /**
     * Updates the DOM with kitchen orders
     * @param {Array} orders - List of orders
     */
    function updateKitchenOrdersDOM(orders) {
      if (!domCache.app) return;

      const newState = JSON.stringify(orders.map(o => ({ id: o.id, status: o.status, timestamp: o.timestamp })));
      if (newState === state.lastOrdersState.kitchen) {
        console.log('No changes in kitchen orders, updating timestamps only');
        updateTimestamps();
        return;
      }
      state.lastOrdersState.kitchen = newState;

      const currentOrderEls = Array.from(document.getElementsByClassName('kitchen-order'));
      const currentOrderIds = currentOrderEls.map(el => el.id.replace('kitchen-order-', ''));

      const newOrderIds = orders.map(o => o.id);

      currentOrderEls.forEach(el => {
        if (!newOrderIds.includes(el.id.replace('kitchen-order-', ''))) {
          el.style.opacity = '0';
          setTimeout(() => el.remove(), 300);
        }
      });

      let html = `<h2>Kitchen Section</h2>`;
      const ordersContainer = document.createElement('div');
      orders.forEach(order => {
        let total = 0;
        let itemLines = [];
        order.items.forEach(item => {
          for (let i = 0; i < item.quantity; i++) {
            itemLines.push(`<li>${item.name} x1 - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`);
            total += item.price;
          }
        });
        const isNew = !currentOrderIds.includes(order.id);
        const receivedTime = new Date(order.timestamp).toLocaleTimeString();
        const minutesSince = Math.floor((Date.now() - order.timestamp) / 60000);
        ordersContainer.innerHTML += `
          <div class="kitchen-order ${isNew ? 'new' : ''}" id="kitchen-order-${order.id}">
            <h3>${order.table}</h3>
            <p class="timestamp">Received: ${receivedTime} | Time since order: ${minutesSince} min</p>
            <ul>${itemLines.join('')}</ul>
            <p class="total-sum">Total: ₹${total}</p>
            <button class="btn-green" onclick="markReady('${order.id}', this)">Mark Ready</button>
          </div>
        `;
      });
      domCache.app.innerHTML = html;
      domCache.app.appendChild(ordersContainer);
    }

    /**
     * Updates timestamps for kitchen orders
     */
    function updateTimestamps() {
      const orders = document.getElementsByClassName('kitchen-order');
      Array.from(orders).forEach(orderEl => {
        const orderId = orderEl.id.replace('kitchen-order-', '');
        const order = state.lastOrdersState.kitchen ? JSON.parse(state.lastOrdersState.kitchen).find(o => o.id === orderId) : null;
        if (order) {
          const timestamp = order.timestamp;
          const receivedTime = new Date(timestamp).toLocaleTimeString();
          const minutesSince = Math.floor((Date.now() - timestamp) / 60000);
          const timestampEl = orderEl.querySelector('.timestamp');
          if (timestampEl) {
            timestampEl.textContent = `Received: ${receivedTime} | Time since order: ${minutesSince} min`;
          }
        }
      });
    }

    /**
     * Marks an order as ready
     * @param {string} orderId - Order ID
     * @param {HTMLElement} button - Button element
     */
    async function markReady(orderId, button) {
      queueAction(async () => {
        button.disabled = true;
        button.classList.add('btn-disabled');
        button.textContent = 'Processing...';
        showLoading(true);
        const startTime = Date.now();
        try {
          const response = await fetchWithRetry(`${DATABASE_URL}orders/${orderId}.json`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'ready' })
          });
          console.log(`Order marked ready: ${orderId}, took ${Date.now() - startTime}ms`);
          const orderEl = document.getElementById(`kitchen-order-${orderId}`);
          if (orderEl) {
            orderEl.style.opacity = '0';
            setTimeout(() => orderEl.remove(), 300);
          }
        } catch (error) {
          console.error('Failed to mark ready:', error);
          alert(`Error marking order as ready: ${error.message}. Check Firebase rules, endpoint, or network.`);
          button.disabled = false;
          button.classList.remove('btn-disabled');
          button.textContent = 'Mark Ready';
        }
        showLoading(false);
        setTimeout(render, 500);
      }, 'markReady');
    }

    /**
     * Renders the admin section
     */
    async function renderAdminSection() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'paid') : [];
        console.log('Admin orders fetched:', orders);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert(`Error loading order history: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }

      if (!domCache.app) return;
      let html = `
        <h2>Admin Section</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
        <h3>Configuration</h3>
        <div>
          <label>Tables:</label>
          <input type="number" id="tables" value="${state.tables}" onchange="updateTables(this.value)">
        </div>
        <div>
          <label><input type="checkbox" id="takeaway" ${state.takeaway ? 'checked' : ''} onchange="updateTakeaway(this.checked)"> Takeaway</label>
        </div>
        <div>
          <h4>Categories</h4>
          <div id="category-items">
            ${categories.map(cat => `
              <div>
                <input type="text" value="${cat}" onchange="updateCategory('${cat}', this.value)">
                <button class="btn-red" onclick="deleteCategory('${cat}')">Delete</button>
              </div>
            `).join('')}
          </div>
          <input type="text" id="new-category" placeholder="New category">
          <button class="btn-blue" onclick="addCategory()">Add Category</button>
        </div>
        <div>
          <h4>Menu</h4>
          <div id="menu-items"></div>
          <button class="btn-blue" onclick="addMenuItem()">Add Menu Item</button>
        </div>
        <button class="btn-purple" onclick="saveConfig()">Save Configuration</button>
        <h3>Order History</h3>
        <button class="btn-blue" onclick="exportOrderHistory()">Download Order History (CSV)</button>
      `;
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        html += `
          <div class="admin-order">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Paid: ${new Date(order.paidTimestamp).toLocaleString()}</p>
          </div>
        `;
      });
      domCache.app.innerHTML = html;

      const menuItems = document.getElementById('menu-items');
      if (menuItems) {
        ['Uncategorized'].concat(categories).forEach(category => {
          const categoryItems = menu.filter(item => (category === 'Uncategorized' ? !item.category : item.category === category));
          if (categoryItems.length > 0) {
            menuItems.innerHTML += `<h5>${category}</h5>`;
            categoryItems.forEach(item => {
              menuItems.innerHTML += `
                <div>
                  <input type="text" value="${item.name}" onchange="updateMenuItem(${item.id}, 'name', this.value)">
                  <input type="number" value="${item.price}" onchange="updateMenuItem(${item.id}, 'price', this.value)">
                  <select onchange="updateMenuItem(${item.id}, 'category', this.value)">
                    <option value="" ${!item.category ? 'selected' : ''}>Uncategorized</option>
                    ${categories.map(cat => `<option value="${cat}" ${item.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                  </select>
                  <label><input type="checkbox" ${item.isFavorite ? 'checked' : ''} onchange="updateMenuItem(${item.id}, 'isFavorite', this.checked)"> Favorite</label>
                  <button class="btn-red" onclick="deleteMenuItem(${item.id})">Delete</button>
                </div>
              `;
            });
          }
        });
      }
      showLoading(false);
    }

    /**
     * Adds a new category
     */
    function addCategory() {
      const input = document.getElementById('new-category');
      const newCategory = input.value.trim();
      if (newCategory && !categories.includes(newCategory)) {
        categories.push(newCategory);
        input.value = '';
        render();
      }
    }

    /**
     * Updates a category name
     * @param {string} oldName - Old category name
     * @param {string} newName - New category name
     */
    function updateCategory(oldName, newName) {
      if (newName && !categories.includes(newName)) {
        categories[categories.indexOf(oldName)] = newName;
        menu.forEach(item => {
          if (item.category === oldName) item.category = newName;
        });
        render();
      }
    }

    /**
     * Deletes a category
     * @param {string} category - Category to delete
     */
    function deleteCategory(category) {
      if (menu.some(item => item.category === category)) {
        alert('Cannot delete category with menu items. Reassign or delete items first.');
        return;
      }
      categories.splice(categories.indexOf(category), 1);
      render();
    }

    /**
     * Adds a new menu item
     */
    function addMenuItem() {
      menu.push({ id: menu.length + 1, name: 'New Item', price: 0, category: '', isFavorite: false });
      render();
    }

    /**
     * Deletes a menu item
     * @param {number} id - Item ID
     */
    function deleteMenuItem(id) {
      const index = menu.findIndex(item => item.id === id);
      if (index !== -1) menu.splice(index, 1);
      render();
    }

    /**
     * Updates a menu item
     * @param {number} id - Item ID
     * @param {string} field - Field to update
     * @param {any} value - New value
     */
    function updateMenuItem(id, field, value) {
      const item = menu.find(item => item.id === id);
      if (item) {
        item[field] = field === 'price' ? parseFloat(value) || 0 : field === 'isFavorite' ? value : value;
        render();
      }
    }

    /**
     * Renders the history section
     */
    async function renderHistorySection() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
        const data = await response.json();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => {
            const timestamp = o.status === 'paid' ? o.paidTimestamp : o.timestamp;
            return timestamp >= today.getTime() && timestamp < tomorrow.getTime();
          })
          .sort((a, b) => (b.paidTimestamp || b.timestamp) - (a.paidTimestamp || a.timestamp)) : [];
        console.log('Today\'s orders fetched:', orders.length);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert(`Error loading today's history: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }

      if (!domCache.app) return;
      let html = `
        <h2>Today's Order History</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
        <button class="btn-red" onclick="deleteAllOrders()">Delete All Orders</button>
      `;
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const timestamp = order.status === 'paid' ? order.paidTimestamp : order.timestamp;
        html += `
          <div class="history-order" id="history-${order.id}">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Status: ${order.status}</p>
            <p>Time: ${new Date(timestamp).toLocaleTimeString()}</p>
            <button class="btn-red" onclick="deleteOrder('${order.id}')">Delete</button>
          </div>
        `;
      });
      domCache.app.innerHTML = html;
      showLoading(false);
    }

    /**
     * Deletes an order
     * @param {string} orderId - Order ID
     */
    async function deleteOrder(orderId) {
      console.log('Attempting to delete order:', orderId);
      if (window.confirm('Are you sure you want to delete this order?') &&
          window.confirm('This action cannot be undone. Confirm deletion?')) {
        showLoading(true);
        try {
          const response = await fetchWithRetry(`${DATABASE_URL}orders/${orderId}.json`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' }
          });
          console.log(`Order deleted successfully: ${orderId}`);
          const orderEl = document.getElementById(`history-${orderId}`);
          if (orderEl) {
            orderEl.style.opacity = '0';
            setTimeout(() => orderEl.remove(), 300);
          }
          renderHistorySection();
        } catch (error) {
          console.error('Failed to delete order:', orderId, error);
          alert(`Error deleting order ${orderId}: ${error.message}. Check Firebase rules, endpoint, or network.`);
        }
        showLoading(false);
      }
    }

    /**
     * Deletes all orders for today
     */
    async function deleteAllOrders() {
      console.log('Attempting to delete all today\'s orders');
      if (window.confirm('Are you sure you want to delete all today\'s orders?') &&
          window.confirm('This action cannot be undone. Confirm deletion?')) {
        showLoading(true);
        try {
          const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
          const data = await response.json();
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const tomorrow = new Date(today);
          tomorrow.setDate(today.getDate() + 1);
          const ordersToDelete = data ? Object.entries(data)
            .filter(([_, order]) => {
              const timestamp = order.status === 'paid' ? order.paidTimestamp : order.timestamp;
              return timestamp >= today.getTime() && timestamp < tomorrow.getTime();
            })
            .map(([id]) => id) : [];

          console.log('Orders to delete:', ordersToDelete);
          const deletePromises = ordersToDelete.map(orderId =>
            fetchWithRetry(`${DATABASE_URL}orders/${orderId}.json`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' }
            }).then(res => ({ id: orderId, ok: res.ok, status: res.status, statusText: res.statusText }))
          );
          const results = await Promise.all(deletePromises);
          results.forEach(result => {
            if (!result.ok) {
              console.error(`Failed to delete order ${result.id}: HTTP ${result.status} ${result.statusText}`);
            } else {
              console.log(`Deleted order ${result.id}`);
            }
          });
          console.log(`Deleted ${results.filter(r => r.ok).length} orders`);
          renderHistorySection();
        } catch (error) {
          console.error('Failed to delete all orders:', error);
          alert(`Error deleting orders: ${error.message}. Check Firebase rules, endpoint, or network.`);
        }
        showLoading(false);
      }
    }

    /**
     * Updates the number of tables
     * @param {string} value - New number of tables
     */
    function updateTables(value) {
      state.tables = parseInt(value) || 10;
      render();
    }

    /**
     * Updates the takeaway setting
     * @param {boolean} checked - Whether takeaway is enabled
     */
    function updateTakeaway(checked) {
      state.takeaway = checked;
      render();
    }

    /**
     * Marks an order as paid
     * @param {string} orderId - Order ID
     * @param {HTMLElement} button - Button element
     */
    const debouncedMarkPaid = debounce(async (orderId, button) => {
      button.disabled = true;
      button.classList.add('btn-disabled');
      button.textContent = 'Processing...';
      showLoading(true);
      const startTime = Date.now();
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders/${orderId}.json`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: 'paid', paidTimestamp: Date.now() })
        });
        console.log(`Order marked paid: ${orderId}, took ${Date.now() - startTime}ms`);
        const orderEl = document.getElementById(`order-${orderId}`);
        if (orderEl) {
          orderEl.style.opacity = '0';
          setTimeout(() => orderEl.remove(), 300);
        }
      } catch (error) {
        console.error('Failed to mark paid:', error);
        alert(`Error marking order as paid: ${error.message}. Check Firebase rules, endpoint, or network.`);
        button.disabled = false;
        button.classList.remove('btn-disabled');
        button.textContent = 'Mark Paid';
      }
      showLoading(false);
      setTimeout(render, 500);
    }, 300);

    function markPaid(orderId, button) {
      queueAction(() => debouncedMarkPaid(orderId, button), 'markPaid');
    }

    /**
     * Exports order history as CSV
     */
    async function exportOrderHistory() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetchWithRetry(`${DATABASE_URL}orders.json`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'paid') : [];
        console.log('Orders exported:', orders);
      } catch (error) {
        console.error('Failed to fetch orders for export:', error);
        alert(`Error exporting order history: ${error.message}. Check Firebase rules, endpoint, or network.`);
      }

      let csvContent = 'Order ID,Table,Items,Total (INR),Paid Timestamp\n';
      orders.forEach(order => {
        const items = order.items.map(item => `${item.name} x${item.quantity} (₹${item.price}) ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}`).join('; ');
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const timestamp = new Date(order.paidTimestamp).toLocaleString();
        csvContent += `"${order.id}","${order.table}","${items}",${total},"${timestamp}"\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `crispydelight_order_history_${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      showLoading(false);
    }

    // Initial load
    loadConfig();
  </script>
</body>
</html>
