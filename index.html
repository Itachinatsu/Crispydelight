<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crispydelight Restaurant</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f0f0f0;
    }
    .container {
      max-width: 360px;
      margin: 0 auto;
      text-align: center;
    }
    h1, h2, h3, h4, h5 {
      color: #333;
    }
    button {
      padding: 10px;
      margin: 8px 4px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    .btn-blue { background-color: #007bff; color: white; }
    .btn-blue:hover { background-color: #0056b3; }
    .btn-green { background-color: #28a745; color: white; }
    .btn-green:hover { background-color: #1e7e34; }
    .btn-purple { background-color: #6f42c1; color: white; }
    .btn-purple:hover { background-color: #5a32a3; }
    .btn-gray { background-color: #6c757d; color: white; }
    .btn-gray:hover { background-color: #545b62; }
    .btn-red { background-color: #dc3545; color: white; }
    .btn-red:hover { background-color: #bd2130; }
    .btn-disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .table-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .order-item, .kitchen-order, .admin-order, .history-order {
      background-color: white;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .order-item.new, .kitchen-order.new, .history-order.new {
      opacity: 0;
      transform: translateY(10px);
      animation: fadeIn 0.3s forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; transform: translateY(0); }
    }
    input, select {
      padding: 5px;
      margin: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    .logo {
      max-width: 100px;
      margin: 10px auto;
    }
    .loading {
      display: none;
      font-size: 14px;
      color: #666;
      text-align: center;
      margin: 10px 0;
    }
    .loading.active {
      display: block;
    }
    .total-sum {
      font-weight: bold;
      margin-top: 10px;
    }
    .takeaway-toggle {
      margin-left: 10px;
      font-size: 14px;
    }
    .category-group {
      margin: 10px 0;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
    }
    .timestamp {
      font-size: 12px;
      color: #666;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="loading" class="loading">Loading...</div>
  <div class="container" id="app">
    <img src="https://via.placeholder.com/100x50?text=Crispydelight" alt="Crispydelight Logo" class="logo">
  </div>
  <script>
    const DATABASE_URL = 'https://crispydelight-7ec1d-default-rtdb.firebaseio.com/';
    let currentSection = 'home';
    let selectedTable = null;
    let selectedOrderId = null; // For editing orders
    let tables = 10;
    let takeaway = true;
    let menu = [
      { id: 1, name: 'Burger', price: 250, category: 'Burgers', isFavorite: false },
      { id: 2, name: 'Mojito', price: 150, category: 'Drinks', isFavorite: true },
      { id: 3, name: 'Pizza', price: 400, category: 'Pizzas', isFavorite: false },
      { id: 4, name: 'Fried Chicken', price: 300, category: 'Snacks', isFavorite: true }
    ];
    let categories = ['Burgers', 'Drinks', 'Pizzas', 'Snacks'];
    let currentOrder = {};
    let pollTimer = null;
    let lastOrdersState = {};
    let actionQueue = [];
    let isFetching = false;

    // Debounce utility
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Queue actions during fetch
    function queueAction(action, type) {
      if (isFetching) {
        actionQueue.push({ action, type });
        console.log(`Action queued: ${type}`);
      } else {
        action();
      }
    }

    // Process queued actions
    function processQueue() {
      while (actionQueue.length > 0) {
        const { action, type } = actionQueue.shift();
        console.log(`Processing queued action: ${type}`);
        action();
      }
    }

    // Load config from Firebase on startup
    async function loadConfig() {
      showLoading(true);
      try {
        const response = await fetch(`${DATABASE_URL}config.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const config = await response.json();
        if (config) {
          tables = config.tables || tables;
          takeaway = config.takeaway !== undefined ? config.takeaway : takeaway;
          menu = config.menu || menu;
          categories = config.categories || categories;
        }
        console.log('Config loaded:', { tables, takeaway, menu, categories });
      } catch (error) {
        console.error('Failed to load config:', error);
        alert('Error loading configuration. Check Firebase rules, endpoint, or network.');
      }
      showLoading(false);
      render();
    }

    // Save config to Firebase
    async function saveConfig() {
      showLoading(true);
      try {
        const response = await fetch(`${DATABASE_URL}config.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tables, takeaway, menu, categories })
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        console.log('Config saved:', { tables, takeaway, menu, categories });
      } catch (error) {
        console.error('Failed to save config:', error);
        alert('Error saving configuration. Check Firebase rules or network.');
      }
      showLoading(false);
    }

    function showLoading(show) {
      const loadingEl = document.getElementById('loading');
      if (loadingEl) {
        loadingEl.classList.toggle('active', show);
      } else {
        console.warn('Loading element not found');
      }
    }

    function render() {
      const app = document.getElementById('app');
      if (!app) {
        console.error('App container not found');
        return;
      }
      app.innerHTML = `
        <img src="https://via.placeholder.com/100x50?text=Crispydelight" alt="Crispydelight Logo" class="logo">
      `;

      if (currentSection === 'home') {
        app.innerHTML += `
          <h1>Crispydelight Dashboard</h1>
          <button class="btn-blue" onclick="navigate('order')">Order Section</button>
          <button class="btn-green" onclick="navigate('kitchen')">Kitchen Section</button>
          <button class="btn-purple" onclick="navigate('admin')">Admin Section</button>
          <button class="btn-blue" onclick="navigate('history')">Today's History</button>
        `;
      } else if (currentSection === 'order' && !selectedTable) {
        renderOrderSection();
      } else if (currentSection === 'order' && selectedTable) {
        renderMenuSection();
      } else if (currentSection === 'kitchen') {
        renderKitchenSection();
      } else if (currentSection === 'admin') {
        renderAdminSection();
      } else if (currentSection === 'history') {
        renderHistorySection();
      }
      showLoading(false); // Ensure loading is cleared
      console.log('Rendered section:', currentSection, 'Selected table:', selectedTable, 'Selected order:', selectedOrderId);
    }

    function navigate(section) {
      if (pollTimer) {
        clearTimeout(pollTimer);
        pollTimer = null;
        console.log('Polling stopped');
      }
      currentSection = section;
      selectedTable = null;
      selectedOrderId = null;
      currentOrder = {};
      lastOrdersState = {};
      showLoading(false);
      render();
      startPolling();
    }

    function startPolling() {
      if (pollTimer) clearTimeout(pollTimer);
      if (currentSection === 'order' && !selectedTable) {
        renderOrderSection();
        pollTimer = setTimeout(startPolling, 10000);
        console.log('Polling started for order (table selection)');
      } else if (currentSection === 'kitchen') {
        renderKitchenSection();
        pollTimer = setTimeout(startPolling, 10000);
        console.log('Polling started for kitchen');
      } else {
        console.log('Polling skipped: section=', currentSection, 'selectedTable=', selectedTable);
      }
    }

    async function renderOrderSection() {
      if (currentSection !== 'order' || selectedTable) {
        console.log('Skipping renderOrderSection: section=', currentSection, 'selectedTable=', selectedTable);
        return;
      }
      isFetching = true;
      showLoading(true);
      let orders = [];
      try {
        const response = await fetch(`${DATABASE_URL}orders.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'pending' || o.status === 'ready')
          .sort((a, b) => a.timestamp - b.timestamp) : [];
        console.log('Orders fetched:', orders);

        // Update DOM incrementally
        updateOrdersDOM(orders, 'order', 'order-item');
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert('Error loading orders. Check Firebase rules, endpoint, or network.');
      }
      showLoading(false);
      isFetching = false;
      processQueue();
    }

    function updateOrdersDOM(orders, section, className) {
      const app = document.getElementById('app');
      if (!app) return;

      // Check if orders have changed
      const newState = JSON.stringify(orders.map(o => ({ id: o.id, status: o.status, timestamp: o.timestamp })));
      if (newState === lastOrdersState[section]) {
        console.log(`No changes in ${section} orders, skipping DOM update`);
        return;
      }
      lastOrdersState[section] = newState;

      // Get current order IDs
      const currentOrderEls = Array.from(document.getElementsByClassName(className));
      const currentOrderIds = currentOrderEls.map(el => el.id.replace(`${section}-`, ''));

      // New order IDs
      const newOrderIds = orders.map(o => o.id);

      // Remove old orders
      currentOrderEls.forEach(el => {
        if (!newOrderIds.includes(el.id.replace(`${section}-`, ''))) {
          el.style.opacity = '0';
          setTimeout(() => el.remove(), 300);
        }
      });

      // Prepare base HTML
      let html = `
        <h2>${section.charAt(0).toUpperCase() + section.slice(1)} Section</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
      `;
      if (section === 'order') {
        html += `
          <h3>Place Order</h3>
          <div class="table-grid">
            ${Array.from({ length: tables }, (_, i) => `<button class="btn-blue" onclick="selectTable('Table ${i + 1}')">Table ${i + 1}</button>`).join('')}
            ${takeaway ? `<button class="btn-blue" onclick="selectTable('Takeaway')">Takeaway</button>` : ''}
          </div>
          <h3>Current Orders</h3>
        `;
      }

      // Add new/updated orders
      const ordersContainer = document.createElement('div');
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const isNew = !currentOrderIds.includes(order.id);
        let orderHtml = `
          <div class="${className} ${isNew ? 'new' : ''}" id="${section}-${order.id}">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Status: ${order.status}</p>
            <button class="btn-blue" onclick="editOrder('${order.id}', '${order.table}')">Edit Order</button>
        `;
        if (order.status === 'ready') {
          orderHtml += `<button class="btn-green" onclick="markPaid('${order.id}', this)">Mark Paid</button>`;
        }
        orderHtml += `</div>`;
        ordersContainer.innerHTML += orderHtml;
      });

      // Update DOM
      app.innerHTML = html;
      app.appendChild(ordersContainer);
      showLoading(false);
    }

    function selectTable(table) {
      queueAction(() => {
        selectedTable = table;
        selectedOrderId = null;
        currentOrder = {};
        console.log('Table selected:', selectedTable);
        render();
      }, 'selectTable');
    }

    async function editOrder(orderId, table) {
      queueAction(async () => {
        showLoading(true);
        try {
          const response = await fetch(`${DATABASE_URL}orders/${orderId}.json`);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const order = await response.json();
          if (!order) throw new Error('Order not found');
          selectedTable = table;
          selectedOrderId = orderId;
          currentOrder = {};
          order.items.forEach(item => {
            const key = `${item.id}_${item.isTakeaway ? 'takeaway' : 'dinein'}`;
            currentOrder[key] = { quantity: item.quantity, isTakeaway: item.isTakeaway };
          });
          console.log('Editing order:', orderId, currentOrder);
          render();
        } catch (error) {
          console.error('Failed to load order for editing:', error);
          alert('Error loading order. Check Firebase rules, endpoint, or network.');
        }
        showLoading(false);
      }, 'editOrder');
    }

    function renderMenuSection() {
      const app = document.getElementById('app');
      if (!app) return;
      const total = Object.entries(currentOrder).reduce((sum, [key, { quantity }]) => {
        const itemId = parseInt(key.split('_')[0]);
        const item = menu.find(m => m.id === itemId);
        return sum + (item ? item.price * quantity : 0);
      }, 0);
      let html = `
        <h2>${selectedTable} ${selectedOrderId ? 'Edit Order' : 'Order'}</h2>
        <button class="btn-gray" onclick="selectTable(null)">Back</button>
      `;

      // Favorites section
      const favoriteItems = menu.filter(item => item.isFavorite);
      if (favoriteItems.length > 0) {
        html += `<div class="category-group"><h3>Favorites</h3>`;
        favoriteItems.forEach(item => {
          const dineinKey = `${item.id}_dinein`;
          const takeawayKey = `${item.id}_takeaway`;
          const dineinOrder = currentOrder[dineinKey] || { quantity: 0, isTakeaway: false };
          const takeawayOrder = currentOrder[takeawayKey] || { quantity: 0, isTakeaway: true };
          html += `
            <div class="order-item">
              <span>${item.name} (₹${item.price}) - Dine-in</span>
              <button class="btn-red" onclick="updateOrder(${item.id}, -1, false)">-</button>
              <span>${dineinOrder.quantity}</span>
              <button class="btn-green" onclick="updateOrder(${item.id}, 1, false)">+</button>
            </div>
            <div class="order-item">
              <span>${item.name} (₹${item.price}) - Takeaway</span>
              <button class="btn-red" onclick="updateOrder(${item.id}, -1, true)">-</button>
              <span>${takeawayOrder.quantity}</span>
              <button class="btn-green" onclick="updateOrder(${item.id}, 1, true)">+</button>
            </div>
          `;
        });
        html += `</div>`;
      }

      // Categories and uncategorized items
      categories.concat(['Uncategorized']).forEach(category => {
        const categoryItems = menu.filter(item => (category === 'Uncategorized' ? !item.category : item.category === category));
        if (categoryItems.length > 0) {
          html += `<div class="category-group"><h3>${category}</h3>`;
          categoryItems.forEach(item => {
            const dineinKey = `${item.id}_dinein`;
            const takeawayKey = `${item.id}_takeaway`;
            const dineinOrder = currentOrder[dineinKey] || { quantity: 0, isTakeaway: false };
            const takeawayOrder = currentOrder[takeawayKey] || { quantity: 0, isTakeaway: true };
            html += `
              <div class="order-item">
                <span>${item.name} (₹${item.price}) - Dine-in</span>
                <button class="btn-red" onclick="updateOrder(${item.id}, -1, false)">-</button>
                <span>${dineinOrder.quantity}</span>
                <button class="btn-green" onclick="updateOrder(${item.id}, 1, false)">+</button>
              </div>
              <div class="order-item">
                <span>${item.name} (₹${item.price}) - Takeaway</span>
                <button class="btn-red" onclick="updateOrder(${item.id}, -1, true)">-</button>
                <span>${takeawayOrder.quantity}</span>
                <button class="btn-green" onclick="updateOrder(${item.id}, 1, true)">+</button>
              </div>
            `;
          });
          html += `</div>`;
        }
      });

      html += `<p class="total-sum">Total: ₹${total}</p>`;
      html += `<button class="btn-blue" onclick="confirmOrder()">Confirm ${selectedOrderId ? 'Updated ' : ''}Order</button>`;
      app.innerHTML = html;
      console.log('Menu section rendered for table:', selectedTable, 'Total:', total);
    }

    function updateOrder(itemId, delta, isTakeaway) {
      queueAction(() => {
        const key = `${itemId}_${isTakeaway ? 'takeaway' : 'dinein'}`;
        if (!currentOrder[key]) {
          currentOrder[key] = { quantity: 0, isTakeaway };
        }
        currentOrder[key].quantity = (currentOrder[key].quantity || 0) + delta;
        if (currentOrder[key].quantity <= 0) {
          delete currentOrder[key];
        }
        render();
      }, 'updateOrder');
    }

    async function confirmOrder() {
      queueAction(async () => {
        const button = document.querySelector('button[onclick="confirmOrder()"]');
        button.disabled = true;
        button.classList.add('btn-disabled');
        button.textContent = 'Processing...';
        const items = Object.entries(currentOrder).map(([key, { quantity, isTakeaway }]) => {
          const itemId = parseInt(key.split('_')[0]);
          const item = menu.find(m => m.id === itemId);
          return { ...item, quantity, isTakeaway };
        }).filter(item => item.quantity > 0);
        if (items.length === 0) {
          alert('Please add items to the order.');
          button.disabled = false;
          button.classList.remove('btn-disabled');
          button.textContent = `Confirm ${selectedOrderId ? 'Updated ' : ''}Order`;
          return;
        }

        showLoading(true);
        try {
          const url = selectedOrderId ? `${DATABASE_URL}orders/${selectedOrderId}.json` : `${DATABASE_URL}orders.json`;
          const method = selectedOrderId ? 'PUT' : 'POST';
          const body = {
            table: selectedTable,
            items,
            status: 'pending',
            timestamp: selectedOrderId ? Date.now() : Date.now() // Update timestamp for edits
          };
          const response = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          console.log(`${selectedOrderId ? 'Order updated' : 'Order confirmed'}:`, { table: selectedTable, items });
          currentOrder = {};
          selectedTable = null;
          selectedOrderId = null;
          render();
          startPolling();
        } catch (error) {
          console.error(`Failed to ${selectedOrderId ? 'update' : 'confirm'} order:`, error);
          alert(`Error ${selectedOrderId ? 'updating' : 'confirming'} order. Check Firebase rules, endpoint, or network.`);
        }
        button.disabled = false;
        button.classList.remove('btn-disabled');
        button.textContent = `Confirm ${selectedOrderId ? 'Updated ' : ''}Order`;
        showLoading(false);
      }, 'confirmOrder');
    }

    async function renderKitchenSection() {
      if (currentSection !== 'kitchen') {
        console.log('Skipping renderKitchenSection: not in kitchen section');
        return;
      }
      isFetching = true;
      showLoading(true);
      let orders = [];
      try {
        const response = await fetch(`${DATABASE_URL}orders.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'pending')
          .sort((a, b) => a.timestamp - b.timestamp) : [];
        console.log('Kitchen orders fetched:', orders);

        // Update DOM incrementally
        updateKitchenOrdersDOM(orders);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert('Error loading kitchen orders. Check Firebase rules, endpoint, or network.');
      }
      showLoading(false);
      isFetching = false;
      processQueue();
    }

    function updateKitchenOrdersDOM(orders) {
      const app = document.getElementById('app');
      if (!app) return;

      // Check if orders have changed
      const newState = JSON.stringify(orders.map(o => ({ id: o.id, status: o.status, timestamp: o.timestamp })));
      if (newState === lastOrdersState.kitchen) {
        console.log('No changes in kitchen orders, updating timestamps only');
        updateTimestamps();
        return;
      }
      lastOrdersState.kitchen = newState;

      // Get current order IDs
      const currentOrderEls = Array.from(document.getElementsByClassName('kitchen-order'));
      const currentOrderIds = currentOrderEls.map(el => el.id.replace('kitchen-order-', ''));

      // New order IDs
      const newOrderIds = orders.map(o => o.id);

      // Remove old orders
      currentOrderEls.forEach(el => {
        if (!newOrderIds.includes(el.id.replace('kitchen-order-', ''))) {
          el.style.opacity = '0';
          setTimeout(() => el.remove(), 300);
        }
      });

      // Prepare base HTML
      let html = `<h2>Kitchen Section</h2>`;
      const ordersContainer = document.createElement('div');
      orders.forEach(order => {
        let total = 0;
        let itemLines = [];
        order.items.forEach(item => {
          for (let i = 0; i < item.quantity; i++) {
            itemLines.push(`<li>${item.name} x1 - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`);
            total += item.price;
          }
        });
        const isNew = !currentOrderIds.includes(order.id);
        const receivedTime = new Date(order.timestamp).toLocaleTimeString();
        const minutesSince = Math.floor((Date.now() - order.timestamp) / 60000);
        ordersContainer.innerHTML += `
          <div class="kitchen-order ${isNew ? 'new' : ''}" id="kitchen-order-${order.id}">
            <h3>${order.table}</h3>
            <p class="timestamp">Received: ${receivedTime} | Time since order: ${minutesSince} min</p>
            <ul>${itemLines.join('')}</ul>
            <p class="total-sum">Total: ₹${total}</p>
            <button class="btn-green" onclick="markReady('${order.id}', this)">Mark Ready</button>
          </div>
        `;
      });
      app.innerHTML = html;
      app.appendChild(ordersContainer);
    }

    function updateTimestamps() {
      const orders = document.getElementsByClassName('kitchen-order');
      Array.from(orders).forEach(orderEl => {
        const orderId = orderEl.id.replace('kitchen-order-', '');
        const order = lastOrdersState.kitchen ? JSON.parse(lastOrdersState.kitchen).find(o => o.id === orderId) : null;
        if (order) {
          const timestamp = order.timestamp;
          const receivedTime = new Date(timestamp).toLocaleTimeString();
          const minutesSince = Math.floor((Date.now() - timestamp) / 60000);
          const timestampEl = orderEl.querySelector('.timestamp');
          if (timestampEl) {
            timestampEl.textContent = `Received: ${receivedTime} | Time since order: ${minutesSince} min`;
          }
        }
      });
    }

    async function markReady(orderId, button) {
      queueAction(async () => {
        button.disabled = true;
        button.classList.add('btn-disabled');
        button.textContent = 'Processing...';
        showLoading(true);
        const startTime = Date.now();
        try {
          const response = await fetch(`${DATABASE_URL}orders/${orderId}.json`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'ready' })
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          console.log(`Order marked ready: ${orderId}, took ${Date.now() - startTime}ms`);
          const orderEl = document.getElementById(`kitchen-order-${orderId}`);
          if (orderEl) {
            orderEl.style.opacity = '0';
            setTimeout(() => orderEl.remove(), 300);
          }
        } catch (error) {
          console.error('Failed to mark ready:', error);
          alert('Error marking order as ready. Check Firebase rules, endpoint, or network.');
          button.disabled = false;
          button.classList.remove('btn-disabled');
          button.textContent = 'Mark Ready';
        }
        showLoading(false);
        setTimeout(render, 500);
      }, 'markReady');
    }

    async function renderAdminSection() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetch(`${DATABASE_URL}orders.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'paid') : [];
        console.log('Admin orders fetched:', orders);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert('Error loading order history. Check Firebase rules, endpoint, or network.');
      }

      const app = document.getElementById('app');
      if (!app) return;
      let html = `
        <h2>Admin Section</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
        <h3>Configuration</h3>
        <div>
          <label>Tables:</label>
          <input type="number" id="tables" value="${tables}" onchange="updateTables(this.value)">
        </div>
        <div>
          <label><input type="checkbox" id="takeaway" ${takeaway ? 'checked' : ''} onchange="updateTakeaway(this.checked)"> Takeaway</label>
        </div>
        <div>
          <h4>Categories</h4>
          <div id="category-items">
            ${categories.map(cat => `
              <div>
                <input type="text" value="${cat}" onchange="updateCategory('${cat}', this.value)">
                <button class="btn-red" onclick="deleteCategory('${cat}')">Delete</button>
              </div>
            `).join('')}
          </div>
          <input type="text" id="new-category" placeholder="New category">
          <button class="btn-blue" onclick="addCategory()">Add Category</button>
        </div>
        <div>
          <h4>Menu</h4>
          <div id="menu-items"></div>
          <button class="btn-blue" onclick="addMenuItem()">Add Menu Item</button>
        </div>
        <button class="btn-purple" onclick="saveConfig()">Save Configuration</button>
        <h3>Order History</h3>
        <button class="btn-blue" onclick="exportOrderHistory()">Download Order History (CSV)</button>
      `;
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        html += `
          <div class="admin-order">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Paid: ${new Date(order.paidTimestamp).toLocaleString()}</p>
          </div>
        `;
      });
      app.innerHTML = html;

      const menuItems = document.getElementById('menu-items');
      if (menuItems) {
        ['Uncategorized'].concat(categories).forEach(category => {
          const categoryItems = menu.filter(item => (category === 'Uncategorized' ? !item.category : item.category === category));
          if (categoryItems.length > 0) {
            menuItems.innerHTML += `<h5>${category}</h5>`;
            categoryItems.forEach(item => {
              menuItems.innerHTML += `
                <div>
                  <input type="text" value="${item.name}" onchange="updateMenuItem(${item.id}, 'name', this.value)">
                  <input type="number" value="${item.price}" onchange="updateMenuItem(${item.id}, 'price', this.value)">
                  <select onchange="updateMenuItem(${item.id}, 'category', this.value)">
                    <option value="" ${!item.category ? 'selected' : ''}>Uncategorized</option>
                    ${categories.map(cat => `<option value="${cat}" ${item.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                  </select>
                  <label><input type="checkbox" ${item.isFavorite ? 'checked' : ''} onchange="updateMenuItem(${item.id}, 'isFavorite', this.checked)"> Favorite</label>
                  <button class="btn-red" onclick="deleteMenuItem(${item.id})">Delete</button>
                </div>
              `;
            });
          }
        });
      }
      showLoading(false);
    }

    function addCategory() {
      const input = document.getElementById('new-category');
      const newCategory = input.value.trim();
      if (newCategory && !categories.includes(newCategory)) {
        categories.push(newCategory);
        input.value = '';
        render();
      }
    }

    function updateCategory(oldName, newName) {
      if (newName && !categories.includes(newName)) {
        categories = categories.map(cat => cat === oldName ? newName : cat);
        menu = menu.map(item => item.category === oldName ? { ...item, category: newName } : item);
        render();
      }
    }

    function deleteCategory(category) {
      if (menu.some(item => item.category === category)) {
        alert('Cannot delete category with menu items. Reassign or delete items first.');
        return;
      }
      categories = categories.filter(cat => cat !== category);
      render();
    }

    function addMenuItem() {
      menu.push({ id: menu.length + 1, name: 'New Item', price: 0, category: '', isFavorite: false });
      render();
    }

    function deleteMenuItem(id) {
      menu = menu.filter(item => item.id !== id);
      render();
    }

    function updateMenuItem(id, field, value) {
      menu = menu.map(item => item.id === id ? { ...item, [field]: field === 'price' ? parseFloat(value) || 0 : field === 'isFavorite' ? value : value } : item);
      render();
    }

    async function renderHistorySection() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetch(`${DATABASE_URL}orders.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const data = await response.json();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => {
            const timestamp = o.status === 'paid' ? o.paidTimestamp : o.timestamp;
            return timestamp >= today.getTime() && timestamp < tomorrow.getTime();
          })
          .sort((a, b) => (b.paidTimestamp || b.timestamp) - (a.paidTimestamp || a.timestamp)) : [];
        console.log('Today\'s orders fetched:', orders);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        alert('Error loading today\'s history. Check Firebase rules, endpoint, or network.');
      }

      const app = document.getElementById('app');
      if (!app) return;
      let html = `
        <h2>Today's Order History</h2>
        <button class="btn-gray" onclick="navigate('home')">Back</button>
        <button class="btn-red" onclick="deleteAllOrders()">Delete All Orders</button>
      `;
      orders.forEach(order => {
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const timestamp = order.status === 'paid' ? order.paidTimestamp : order.timestamp;
        html += `
          <div class="history-order" id="history-${order.id}">
            <h4>${order.table}</h4>
            <ul>
              ${order.items.map(item => `<li>${item.name} x${item.quantity} - ₹${item.price} ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}</li>`).join('')}
            </ul>
            <p class="total-sum">Total: ₹${total}</p>
            <p>Status: ${order.status}</p>
            <p>Time: ${new Date(timestamp).toLocaleTimeString()}</p>
            <button class="btn-red" onclick="deleteOrder('${order.id}')">Delete</button>
          </div>
        `;
      });
      app.innerHTML = html;
      showLoading(false);
    }

    async function deleteOrder(orderId) {
      console.log('Attempting to delete order:', orderId);
      if (window.confirm('Are you sure you want to delete this order?') &&
          window.confirm('This action cannot be undone. Confirm deletion?')) {
        showLoading(true);
        try {
          const response = await fetch(`${DATABASE_URL}orders/${orderId}.json`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' }
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          console.log(`Order deleted successfully: ${orderId}`);
          const orderEl = document.getElementById(`history-${orderId}`);
          if (orderEl) {
            orderEl.style.opacity = '0';
            setTimeout(() => orderEl.remove(), 300);
          }
        } catch (error) {
          console.error('Failed to delete order:', error);
          alert('Error deleting order. Check Firebase rules, endpoint, or network.');
        }
        showLoading(false);
        setTimeout(() => render(), 500); // Delayed re-render
      }
    }

    async function deleteAllOrders() {
      console.log('Attempting to delete all today\'s orders');
      if (window.confirm('Are you sure you want to delete all today\'s orders?') &&
          window.confirm('This action cannot be undone. Confirm deletion?')) {
        showLoading(true);
        try {
          const response = await fetch(`${DATABASE_URL}orders.json`);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const data = await response.json();
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const tomorrow = new Date(today);
          tomorrow.setDate(today.getDate() + 1);
          const ordersToDelete = data ? Object.entries(data)
            .filter(([_, order]) => {
              const timestamp = order.status === 'paid' ? order.paidTimestamp : order.timestamp;
              return timestamp >= today.getTime() && timestamp < tomorrow.getTime();
            })
            .map(([id]) => id) : [];

          console.log('Orders to delete:', ordersToDelete);
          for (const orderId of ordersToDelete) {
            const delResponse = await fetch(`${DATABASE_URL}orders/${orderId}.json`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' }
            });
            if (!delResponse.ok) throw new Error(`HTTP ${delResponse.status}: ${delResponse.statusText}`);
          }
          console.log(`Deleted ${ordersToDelete.length} orders`);
          render();
        } catch (error) {
          console.error('Failed to delete all orders:', error);
          alert('Error deleting orders. Check Firebase rules, endpoint, or network.');
        }
        showLoading(false);
      }
    }

    function updateTables(value) {
      tables = parseInt(value) || 10;
      render();
    }

    function updateTakeaway(checked) {
      takeaway = checked;
      render();
    }

    const debouncedMarkPaid = debounce(async (orderId, button) => {
      button.disabled = true;
      button.classList.add('btn-disabled');
      button.textContent = 'Processing...';
      showLoading(true);
      const startTime = Date.now();
      try {
        const response = await fetch(`${DATABASE_URL}orders/${orderId}.json`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: 'paid', paidTimestamp: Date.now() })
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        console.log(`Order marked paid: ${orderId}, took ${Date.now() - startTime}ms`);
        const orderEl = document.getElementById(`order-${orderId}`);
        if (orderEl) {
          orderEl.style.opacity = '0';
          setTimeout(() => orderEl.remove(), 300);
        }
      } catch (error) {
        console.error('Failed to mark paid:', error);
        alert('Error marking order as paid. Check Firebase rules, endpoint, or network.');
        button.disabled = false;
        button.classList.remove('btn-disabled');
        button.textContent = 'Mark Paid';
      }
      showLoading(false);
      setTimeout(render, 500);
    }, 300);

    async function markPaid(orderId, button) {
      queueAction(() => debouncedMarkPaid(orderId, button), 'markPaid');
    }

    async function exportOrderHistory() {
      showLoading(true);
      let orders = [];
      try {
        const response = await fetch(`${DATABASE_URL}orders.json`);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const data = await response.json();
        orders = data ? Object.entries(data)
          .map(([id, order]) => ({ id, ...order }))
          .filter(o => o.status === 'paid') : [];
        console.log('Orders exported:', orders);
      } catch (error) {
        console.error('Failed to fetch orders for export:', error);
        alert('Error exporting order history. Check Firebase rules, endpoint, or network.');
      }

      let csvContent = 'Order ID,Table,Items,Total (INR),Paid Timestamp\n';
      orders.forEach(order => {
        const items = order.items.map(item => `${item.name} x${item.quantity} (₹${item.price}) ${item.isTakeaway ? '(Takeaway)' : '(Dine-in)'}`).join('; ');
        const total = order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        const timestamp = new Date(order.paidTimestamp).toLocaleString();
        csvContent += `"${order.id}","${order.table}","${items}",${total},"${timestamp}"\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `crispydelight_order_history_${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      showLoading(false);
    }

    // Initial load
    loadConfig();
  </script>
</body>
</html>
